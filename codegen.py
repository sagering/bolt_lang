from lexer import lex
from typing import Union
from parser import TokenSource, parse_module, print_parser_error
from validator import validate_module
from collections import defaultdict
from validator import ValidatedModule, ValidatedFunctionDefinition, ValidatedBlock, ValidatedReturnStatement, \
    ValidatedVariableDeclaration, ValidatedWhileStatement, ValidatedBreakStatement, ValidatedIfStatement, \
    ValidatedExpression, ValidatedNameExpr, ValidatedNumber, ValidatedCall, ValidatedBinaryOperation, \
    ValidatedUnaryOperation, ValidatedDotExpression, ValidatedIndexExpression, ValidatedStructExpression,\
    ValidatedStatement, CompleteType, ValidatedNode, visit_nodes, ValidatedField, ValidatedReturnType, \
    ValidatedParameter


# TODO: It feels like this function is badly named, but I am not sure what to call it yet.
def c_typename_with_wrapped_pointers(complete_type: CompleteType) -> str:
    """
    The purpose of this function is to generate an alphabetic name (including underscores)
    for any type, e.g. a type [3][]*B will be named ARRAY_3_SLICE_PTR_B. This name will then
    be used pre-declare and finally define the respective struct in C, and whenever this type will
    be used in C, e.g. as part of a struct field or variable declaration.
    """

    if complete_type.is_pointer():
        return 'PTR_' + c_typename_with_wrapped_pointers(complete_type.next)

    if complete_type.is_slice():
        return 'SLICE_' + c_typename_with_wrapped_pointers(complete_type.next)

    if complete_type.is_array():
        return f'ARRAY_{complete_type.array().length}_' + c_typename_with_wrapped_pointers(complete_type.next)

    if complete_type.is_builtin():
        return complete_type.builtin().name

    if complete_type.is_struct():
        return complete_type.struct().location.replace('.', '_') + '_' + complete_type.struct().name

    raise NotImplementedError(complete_type)


def c_typename_with_ptrs(type: CompleteType) -> str:
    """
    Consider the following example:

    The type [3]*[2]B becomes

    struct ARRAY_2_B
    {
        B array[2];
    };

    struct ARRAY_3_PTR_ARRAY_2_B
    {
        ARRAY_2_B* array[3]; // <-- ARRAY_2_B* is generated by this function (as opposed to PTR_ARRAY_2_B).
    };
    """

    pointers = ''

    while type.is_pointer():
        pointers += '*'
        type = type.next

    return c_typename_with_wrapped_pointers(type) + pointers


def decay(complete_type : CompleteType) -> CompleteType:
    """Removes pointers and slices to expose the underlying type of complete type."""
    if complete_type.is_pointer() or complete_type.is_slice():
        return decay(complete_type.next)
    return complete_type


def codegen_prelude() -> str:
    out = '// PRELUDE\n'
    out += '#define i32 int\n'
    out += '#define i64 long\n'
    return out


def codegen_slices(type_dict : dict[str, CompleteType]) -> str:
    out = '// SLICES\n'
    for k, v in type_dict.items():
        if v.is_slice():
            out += f'struct {c_typename_with_wrapped_pointers(v)} {{\n'
            pointers = '*'
            t = v.next
            if v.next.is_pointer():
                while t.is_pointer():
                    pointers += '*'
                    t = t.next
            out += f'{c_typename_with_wrapped_pointers(t)}{pointers} to;\n'
            out += 'i32 length;\n'
            out += '};\n'
    return out


def codegen_struct_predeclarations(type_dict : dict[str, CompleteType]) -> str:
    out = '// STRUCT PRE-DECLARATIONS\n'
    for k, v in type_dict.items():
        if v.is_builtin() or v.is_function_ptr() or decay(v).is_builtin():
            continue
        out += f'struct {c_typename_with_wrapped_pointers(v)};\n'
    return out


def codegen_struct_definitions(type_dict: dict[str, CompleteType]) -> str:
    # Build a dependency graph between the structs.
    out_edges = defaultdict(list)
    in_edges = defaultdict(list)

    no_dependency = set()

    for key, type in type_dict.items():
        # downstream type can be pre-declared
        if type.is_pointer() or type.is_slice():
            continue

        if type.is_struct():
            for field in type.struct().fields:

                if field.type.is_pointer() or field.type.is_slice() or field.type.is_builtin():
                    continue

                out_edges[type.to_string()].append(field.type.to_string())
                in_edges[field.type.to_string()].append(type.to_string())

        if type.is_array():
            if not (type.next.is_pointer() or type.next.is_slice() or type.next.is_builtin()):
                out_edges[type.to_string()].append(type.next.to_string())
                in_edges[type.next.to_string()].append(type.to_string())

        if len(out_edges[key]) == 0:
            no_dependency.add(key)

    # Kahn's algorithm for topological sorting.
    ordered = []
    while len(no_dependency) > 0:
        type_id = no_dependency.pop()

        for other in in_edges[type_id]:
            out_edges[other].remove(type_id)
            if len(out_edges[other]) == 0:
                no_dependency.add(other)

        ordered.append(type_id)

    # Dependency graph has cycles there are any edges left, i.e. if any of node's out edge list is not empty.
    # This is not supposed to happen because the types should have been checked already in the validate step.
    for type_id, edges in out_edges.items():
        assert(len(edges) == 0)

    out = '// STRUCT DEFINITIONS\n'
    for key in ordered:
        type = type_dict[key]

        if type.is_builtin() or type.is_function_ptr():
            continue

        if type.is_struct():
            struct = type.struct()

            out += f'struct {c_typename_with_wrapped_pointers(type)} {{\n'
            for field in struct.fields:
                if field.type.is_pointer():
                    pointers = ''
                    t = field.type
                    while t.is_pointer():
                        pointers += '*'
                        t = t.next
                    out += f'{c_typename_with_wrapped_pointers(t)}{pointers} {field.name};\n'
                else:
                    out += f'{c_typename_with_wrapped_pointers(field.type)} {field.name};\n'
            out += '};\n'

        elif type.is_array():
            out += f'struct {c_typename_with_wrapped_pointers(type)} {{\n'
            if type.next.is_pointer():
                pointers = ''
                t = type.next
                while t.is_pointer():
                    pointers += '*'
                    t = t.next
                out += f'{c_typename_with_wrapped_pointers(t)}{pointers} array[{type.array().length}];\n'
            else:
                out += f'{c_typename_with_wrapped_pointers(type.next)} array[{type.array().length}];\n'
            out += '};\n'

    return out


def codegen_expr(expr: ValidatedExpression) -> str:
    if isinstance(expr, ValidatedNumber):
        return f'({expr.value})'
    elif isinstance(expr, ValidatedNameExpr):
        return f'{expr.name}'
    elif isinstance(expr, ValidatedUnaryOperation):
        return f'({expr.op.op.literal()}{codegen_expr(expr.rhs())})'
    elif isinstance(expr, ValidatedBinaryOperation):
        return f'({codegen_expr(expr.lhs())}{expr.op.op.literal()}{codegen_expr(expr.rhs())})'
    elif isinstance(expr, ValidatedCall):
        return f'({codegen_expr(expr.expr())}({",".join([codegen_expr(arg) for arg in expr.args()])}))'
    elif isinstance(expr, ValidatedDotExpression):
        deref = '*' if expr.auto_deref else ''
        return f'(({deref}{codegen_expr(expr.expr())}).{expr.name().name})'
    elif isinstance(expr, ValidatedStructExpression):
        return f'({c_typename_with_ptrs(expr.type)}' + '{})'
    elif isinstance(expr, ValidatedIndexExpression):
        return f'({codegen_expr(expr.expr())}.array[{codegen_expr(expr.index())}])'
    else:
        raise NotImplementedError(expr)


def codegen_function_definition(validated_function_definition : ValidatedFunctionDefinition, predeclaration : bool) -> str:
    out = ''
    pars = ','.join([f'{c_typename_with_ptrs(par.type)} {par.name}' for par in validated_function_definition.pars()])
    out += f'{c_typename_with_ptrs(validated_function_definition.return_type().type)} {validated_function_definition.name().name} ({pars})'

    if predeclaration:
        out += ';\n'
    else:
        out += '{\n'
        for substmt in validated_function_definition.body().statements():
            out += codegen_stmt(substmt)
        out += '}\n'

    return out


def codegen_stmt(stmt: ValidatedStatement) -> str:
    out = ''
    if isinstance(stmt, ValidatedFunctionDefinition):
        out += codegen_function_definition(stmt, False)
    elif isinstance(stmt, ValidatedVariableDeclaration):
        out += f'{c_typename_with_ptrs(stmt.type)} {stmt.name} = {codegen_expr(stmt.expr())};\n'
    elif isinstance(stmt, ValidatedReturnStatement):
        out += f'return {codegen_expr(stmt.expr())};\n'
    elif isinstance(stmt, ValidatedBreakStatement):
        out += 'break;\n'
    elif isinstance(stmt, ValidatedWhileStatement):
        out += f'while ({codegen_expr(stmt.condition())}) {{\n'
        for substmt in stmt.block().statements():
            out += codegen_stmt(substmt)
        out += '}\n'
    elif isinstance(stmt, ValidatedExpression):
        out += codegen_expr(stmt) + ';\n'
    else:
        raise NotImplementedError(stmt)

    return out


def codegen_variable_definitions(validated_module : ValidatedModule) -> str:
    out = '// VARIABLE DEFINITIONS\n'
    for stmt in validated_module.body():
        if isinstance(stmt, ValidatedVariableDeclaration):
            out += codegen_stmt(stmt)
    return out


def codegen_function_predeclarations(validated_module: ValidatedModule) -> str:
    out = '// FUNCTION PRE-DECLARATIONS\n'
    for stmt in validated_module.body():
        if isinstance(stmt, ValidatedFunctionDefinition):
            out += codegen_function_definition(stmt, predeclaration=True)

    return out


def codegen_function_definitions(validated_module: ValidatedModule) -> str:
    out = '// FUNCTION DEFINITIONS\n'
    for stmt in validated_module.body():
        if isinstance(stmt, ValidatedFunctionDefinition):
            out += codegen_stmt(stmt)
    return out


def codegen_module(validated_module: ValidatedModule) -> str:

    type_dict = {}

    # Collect all type that we encounter in this module.
    def collect_type(node : ValidatedNode) -> None:
        TypedNodes = Union[ValidatedField, ValidatedReturnType, ValidatedParameter, ValidatedVariableDeclaration]
        if isinstance(node, TypedNodes):
            node.type.collect_downstream_types(type_dict)
        elif hasattr(node, 'type'):
            node.type.collect_downstream_types(type_dict)

    visit_nodes(validated_module, collect_type)

    out = ''
    out += codegen_prelude()
    out += codegen_struct_predeclarations(type_dict)
    out += codegen_slices(type_dict)
    out += codegen_struct_definitions(type_dict)
    out += codegen_variable_definitions(validated_module)
    out += codegen_function_predeclarations(validated_module)
    out += codegen_function_definitions(validated_module)

    return out


def main():
    file_name = 'tests/example.bolt'

    with open(file_name, 'r') as f:
        text = f.read()

    (tokens, error) = lex(text)
    if error:
        print(error)
        return

    token_source = TokenSource(tokens, 0, text)
    (parsed_module, error) = parse_module(token_source)

    if error: return print_parser_error(error, text)

    validated_module, error = validate_module(parsed_module)
    if error: return print(error)

    code = codegen_module(validated_module)
    print(code)


if __name__ == '__main__':
    main()
